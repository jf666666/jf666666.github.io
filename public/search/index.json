[{"content":" # 题目描述 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。\n这个王国有一个明确规定的王位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。\nSuccessor(x, curOrder): 如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中： 如果 x 是国王，那么返回 null 否则，返回 Successor(x 的父亲, curOrder) 否则，返回 x 不在 curOrder 中最年长的孩子 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。\n一开始， curOrder 为 [\u0026ldquo;king\u0026rdquo;]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Jack\u0026rdquo;] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Jack\u0026rdquo;, \u0026ldquo;Bob\u0026rdquo;] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;Alice\u0026rdquo;, \u0026ldquo;Jack\u0026rdquo;, \u0026ldquo;Bob\u0026rdquo;] 。 通过以上的函数，我们总是能得到一个唯一的继承顺序。\n请你实现 ThroneInheritance 类：\nThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。\n# 思路 # DFS 思路很简单，就是用一个map记录每个人的后代，有点像邻接表，然后dfs遍历就可以得到继承顺序，还有注意不要把死人加进顺序，可以用一个set记录哪些人死了。\n# 启发 这道题不难，但是我学到了一些很实用的知识，主要是c++的知识。\n我的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class ThroneInheritance { public: unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; family; unordered_set\u0026lt;string\u0026gt; dead; string kingName; ThroneInheritance(string kingName) { this-\u0026gt;kingName = kingName; family[kingName] = {}; } void birth(string parentName, string childName) { family[parentName].push_back(childName); } void death(string name) { dead.insert(name); } vector\u0026lt;string\u0026gt; getInheritanceOrder() { vector\u0026lt;string\u0026gt; order; successor(this-\u0026gt;kingName,order); return order; } void successor(string name,vector\u0026lt;string\u0026gt;\u0026amp; order){ if(!isDead(name)){ order.push_back(name); } for(auto c:family[name]){ successor(c, order); } } bool isDead(string name){ auto it = dead.find(name); return it != dead.end(); } }; 别人的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class ThroneInheritance { private: unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; edges; unordered_set\u0026lt;string\u0026gt; dead; string king; public: ThroneInheritance(string kingName): king{move(kingName)} {} void birth(string parentName, string childName) { edges[move(parentName)].push_back(move(childName)); } void death(string name) { dead.insert(move(name)); } vector\u0026lt;string\u0026gt; getInheritanceOrder() { vector\u0026lt;string\u0026gt; ans; function\u0026lt;void(const string\u0026amp;)\u0026gt; preorder = [\u0026amp;](const string\u0026amp; name) { if (!dead.count(name)) { ans.push_back(name); } if (edges.count(name)) { for (const string\u0026amp; childName: edges[name]) { preorder(childName); } } }; preorder(king); return ans; } }; 两个 ThroneInheritance类的实现在功能上是等价的：它们都使用深度优先搜索（DFS）来遍历家族树，生成继承顺序的列表，同时考虑已经去世的成员。主要的区别在于类成员的初始化、数据结构的操作以及递归函数的定义和调用方式。尽管这些区别对于功能实现来说是微不足道的，它们可能会影响到代码的运行时性能和内存使用，具体如下：\n# 成员变量初始化： 第一个实现中使用 move语义直接初始化 king变量和在 birth、death方法中使用 move语义插入元素，这可以减少字符串的复制次数，从而可能稍微减少内存使用和提高性能。 第二个实现中对于 kingName的初始化使用的是直接赋值，这可能涉及到字符串的复制。 # 递归函数定义： 第一个实现中使用了lambda表达式定义了递归函数，这种方法可能会让编译器更容易进行优化，特别是在内联函数调用方面。 第二个实现中，递归函数 successor作为类的成员函数实现，这意味着每次调用都需要传递 this指针，增加了调用的开销。 # 数据结构操作： 在两个实现中，数据结构的操作方式基本一致，但是在如何访问和修改 family或 edges和 dead时，细节上的处理（如是否使用 move语义）可能会导致实际性能的微小差异。 # map和set 第一个实现中在递归时，我发现我没进行判断有没有后代： 1 if (family.count(name)) 我以为就算没有后代，接下来的for循环会直接结束的吧，看来实际情况和我想的不一样，如果 family映射中没有给定名称 name的条目，那么 family[name]将返回一个新的、空的 vector\u0026lt;string\u0026gt;实例。在这种情况下，紧随其后的 for循环应该会立即结束，因为它迭代的是一个空容器。\n1 2 3 for(const string\u0026amp; c:family[name]){ successor(c); } 如果 name没有对应的后代（即 family中没有 name的键），按照上面的代码逻辑，family[name]将创建一个新的空 vector，并立即返回。这意味着循环确实应该直接结束，不执行任何迭代。\n然而，调用 family[name]时有一个副作用：如果 family中不存在键 name，这个操作会在 family中插入一个新的键值对，键是 name，值是一个空的 vector\u0026lt;string\u0026gt;。这是 std::unordered_map的标准行为，即使用下标操作符 []访问映射时，如果键不存在，会自动创建它。\n这个副作用意味着即使对于没有后代的成员，family映射的大小也可能增加。 正是这个副作用导致我的代码运行内存比第二个实现要高。\n这不会影响 for循环的执行（因为新插入的向量是空的)，但确实会改变 family映射的状态，这可能不是你想要的结果，特别是在考虑内存使用和性能的时候。因为每次调用 getInheritanceOrder时，对于没有后代的成员也会增加新条目，这可能会导致 family的大小不必要地增加。\n因此，加上 if (family.count(name))这样的判断是有意义的，它可以避免不必要地向 family中添加新的空向量，尤其是在不需要为没有后代的成员记录空向量的情况下。这个判断确保了只有当 name实际上有后代时，才会执行对应的递归调用，这样可以优化性能和内存使用，避免不必要的映射扩展。\n总结来说，即使在没有明确后代的情况下 for循环本身会直接结束，检查 family.count(name)可以避免因为访问不存在的键而导致的 unordered_map不必要的修改和潜在性能影响。\n","date":"2024-04-07T12:59:21+08:00","image":"http://localhost:1313/categories/leetcode/cover.png","permalink":"http://localhost:1313/p/2024/04/throne-inheritance/","title":"王位继承顺序"},{"content":" # 题目描述 给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。\n树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。\n实现 TreeAncestor 类：\nTreeAncestor（int n， int[] parent） 对树和父数组中的节点数初始化对象。 getKthAncestor(int node, int k) 返回节点 node 的第 k 个祖先节点。如果不存在这样的祖先节点，返回 -1 。\n# 思路 # 无限递归 一开始发现可以这样递归找到指定的 parent，提交后发现会超时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class TreeAncestor { public: vector\u0026lt;int\u0026gt; p; unordered_map\u0026lt;int,unordered_map\u0026lt;int,int\u0026gt;\u0026gt; record; TreeAncestor(int n, vector\u0026lt;int\u0026gt;\u0026amp; parent) { this-\u0026gt;p = parent; } int getKthAncestor(int node, int k) { if (node\u0026lt;0) return -1; if (k==0) return node; int cur_parent = this-\u0026gt;p[node]; return getKthAncestor(cur_parent,k-1); } }; # 使用备忘录 使用备忘录记录每个节点的信息，如果之前访问过就直接返回，避免进入递归，但还是超时了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class TreeAncestor { public: vector\u0026lt;int\u0026gt; p; unordered_map\u0026lt;int,unordered_map\u0026lt;int,int\u0026gt;\u0026gt; record; TreeAncestor(int n, vector\u0026lt;int\u0026gt;\u0026amp; parent) { this-\u0026gt;p = parent; } int getKthAncestor(int node, int k) { auto it = record.find(node); if (it != record.end()){ auto r = it-\u0026gt;second; auto i = r.find(k); if (i!=r.end()){ return i-\u0026gt;second; } } if (node\u0026lt;0) { record[node][k] = -1; return -1; } if (k==0) { return node; } int cur_parent = this-\u0026gt;p[node]; int res = getKthAncestor(cur_parent,k-1); record[node][k] = res; return res; } }; # 二进制提升 这个问题可以通过预处理和动态规划的方法来解决。我们的目标是快速查询树中任意节点的第 (k) 个祖先节点。由于直接逐个遍历祖先节点可能会导致查询时间过长，特别是在树很大或查询很频繁的情况下，我们可以使用一种名为“二进制提升”的技术进行优化。\n二进制提升的基本思想是预处理每个节点的第 (1, 2, 4, 8, \\ldots, 2^i) 个祖先节点（这里的 (i) 使得 (2^i) 小于等于树的高度）。这样，对于任意的查询 getKthAncestor(node, k)，我们可以将 (k) 表示为二进制数，并通过已预处理的祖先信息以对数时间复杂度找到答案。\n# 实现步骤 初始化：\n创建一个数组 ancestor[node][i]，其中 ancestor[node][i] 表示节点 node 的第 (2^i) 个祖先是谁。对于初始化，ancestor[node][0] 是给定的 parent[node]。 预处理：\n使用动态规划填充 ancestor 数组。对于每个节点 node 和每个 (i \u0026gt; 0)，有 ancestor[node][i] = ancestor[ancestor[node][i-1]][i-1]。这里的意思是，节点 node 的第 (2^i) 个祖先是其第 (2^{i-1}) 个祖先的第 (2^{i-1}) 个祖先。 查询：\n对于查询 getKthAncestor(node, k)，将 (k) 转换为二进制表示。然后从高位开始，对于每个为 1 的位 i，更新 node = ancestor[node][i]。如果在某次更新中 node 变成了 -1 或在过程结束后 node 为 -1，则返回 -1 表示不存在第 (k) 个祖先。否则，返回最终的 node。 # 示例代码（C++） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class TreeAncestor { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ancestor; TreeAncestor(int n, vector\u0026lt;int\u0026gt;\u0026amp; parent) { ancestor = vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(20, -1)); for (int i = 0; i \u0026lt; n; ++i) { ancestor[i][0] = parent[i]; } for (int j = 1; j \u0026lt; 20; ++j) { for (int i = 0; i \u0026lt; n; ++i) { if (ancestor[i][j-1] != -1) { ancestor[i][j] = ancestor[ancestor[i][j-1]][j-1]; } } } } int getKthAncestor(int node, int k) { for (int i = 0; i \u0026lt; 20; ++i) { if (k \u0026amp; (1 \u0026lt;\u0026lt; i)) { node = ancestor[node][i]; if (node == -1) break; } } return node; } }; 这个实现能够在对数时间内处理每次查询，从而显著提高查询效率，尤其是在面对大量查询的情况下。\n","date":"2024-04-06T16:33:45+08:00","image":"http://localhost:1313/categories/leetcode/cover.png","permalink":"http://localhost:1313/p/2024/04/kth-ancestor-of-a-tree-node/","title":"树节点的第K个祖先"},{"content":" # 环境配置文档 # CUDA # 安装包下载 前往CUDA Toolkit Archive 下载在之前提到的Cuda 12.1版本，这里选择CUDA Toolkit 12.1.1进行下载，点击链接进入，选择Windows、x86_64、10、exe(local)，点击网页中的exe(local)开始下载。 # CUDA安装 下载完成后得到一个大概3g的安装包，打开进行安装，选择一个临时目录进行解压，点击ok 等待解压完成 解压完成后进入安装界面，这里也需要等待 点击同意并继续 点击自定义后点击下一步 展开CUDA选项取消勾选Visual Studio Integration，如图所示，其余不动，点击下一步 安装位置不需要修改，直接点击下一步 等待安装结束即可 # cuDNN # 压缩包下载 cuDNN和CUDA是配套的，需下载相对应的版本，进入cuDNN官网 需要注册账号后才能进行下载 注册好账号之后点击Download cuDNN Library按钮进入下图的下载界面 同意协议后，选择for CUDA 12.x进行下一个界面 这里选择第一个Local install for Windows(Zip)进行下载 # cuDNN安装 下载完成后得到一个压缩包 解压该压缩包可以看到其中有三个文件夹 选择三个文件夹bin、include、lib并复制到CUDA的安装目录，默认目录为 1 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1 复制过程中出现弹窗，选择替换即可 4. 将CUDA添加到环境变量中\n按WIN+R，打开【运行】对话框。 输入sysdm.cpl，点【确定】按钮，点开高级选项卡，点开环境变量 选择系统变量中的Path，点击编辑，在这里需要添加CUDA的相关路径，有四个，进入先前的CUDA安装路径，点击右上侧的新建按钮，添加以下路径 1 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1\\bin 1 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1\\include 1 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1\\lib 1 C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.1\\libnvvp # Conda Conda本身是一个开源的包管理和环境管理系统，用于安装、运行和升级包和其依赖。Conda可以在不同的Python发行版中使用，其中Anaconda和Miniconda是最著名的两种发行版，它们都包括了conda这个工具。 环境管理器：\n创建隔离环境： Conda允许用户创建隔离的环境，每个环境都可以有不同的Python版本和/或包。这对于管理不同项目的依赖非常有用，避免了包之间的冲突。 环境复制： 可以轻松地复制和共享环境，这对于确保代码在不同计算机或用户之间可重复是非常有用的。 Conda是一个强大的工具，主要用于科学计算领域，它的作用可以从几个不同的方面来理解： # 安装包下载 本文档选择Anaconda进行安装，进入Anaconda下载，下载Windows版本的安装包即可 # 安装与配置 # 安装 打开下载好的安装包进行安装步骤 点击Next进入下一步 点击I Agree同意协议 保持默认选择Just Me，点击下一步 这里可以选择其他安装位置，最好是默认的 仍然保持默认选择，点击Install进行安装，等待安装完成 # 配置 主要是配置环境变量，步骤与配置CUDA的步骤一样\n按WIN+R，打开【运行】对话框。 输入sysdm.cpl，点【确定】按钮，点开高级选项卡，点开环境变量 选择系统变量中的Path，点击编辑，在这里需要添加Conda的相关路径，有三个，进入先前的Conda安装路径，点击右上侧的新建按钮，添加以下路径 1 D:\\ProgramData\\anaconda3 1 D:\\ProgramData\\anaconda3\\condabin 1 D:\\ProgramData\\anaconda3\\Library\\bin 注意：这里的D:\\ProgramData\\anaconda3是anaconda的安装路径，应该替换为你实际的安装地址，添加路径之后应该是这样的\n# Visual Studio Code # 下载安装包 进入vscode官网，下载Windows的Stable安装包 # 配置环境 在VScode中配置python的运行环境\n设置VScode语言为中文 点击左侧的扩展按钮，搜索Chinese插件并安装 按下快捷键Ctrl+Shift+P，输入config display language，选择中文即可 安装Python扩展，在左侧扩展栏搜索Python、Python Environment Manager进行安装 Conda设置 打开vscode设置，搜索conda，在下图中填入conda路径即可 # PyTorch Pytorch是yolo进行检测与训练需要的最基本的库，也需要根据当前最新的pytorch支持的cuda版本，选择对应版本的CUDA安装， 在网站中Pytorch Build选择Stable，Your OS选择Windows，Package选择Pip，Language选择Python，Compute Platform选择较新的版本（是因为4060ti是较新的显卡），即CUDA 12.1，最终选择如图，复制最后的Run this Command\n1 pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121 # PowerShell配置 前面的conda安装好之后，需要对PowerShell进行简单的配置\n在菜单栏中找到PowerShell，点击以管理员身份运行。 打开后执行以下命令 1 conda init 更改PowerShell的脚本执行策略为Unrestricted，通过如下命令进行设置 1 Set-ExecutionPolicy Unrestricted 运行Get-ExecutionPolicy以确认更改已生效\n# Python 配置一个独立的python环境\n# 使用conda创建一个虚拟环境 打开vscode，新建一个终端 在终端中输入以下命令创建一个环境 1 conda create -n auto_template python==3.9 激活环境 创建完成后输入conda activate auto_template激活环境，在输入之前的pytorch命令安装pytorch 1 pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121 安装完成后，创建一个测试用的python文件，输入以下代码\n1 2 import torch print(torch.cuda.is_available()) 运行后查看输出是否为True，为True则代表安装一切顺利 ","date":"2024-04-03T22:34:22+08:00","image":"http://localhost:1313/p/2024/04/pytorch-setup/cover_hue4cf8263671cb51764d64cca1874054f_52745_120x120_fill_box_smart1_3.png","permalink":"http://localhost:1313/p/2024/04/pytorch-setup/","title":"在Windows配置PyTroch，含conda、cuda等"}]